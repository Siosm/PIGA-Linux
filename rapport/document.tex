\documentclass[pdftex,a4paper,titlepage,11pt]{article}

% Les packages de base pour le support du français
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}

% La bonne police, sans serif, helvetica
\usepackage[scaled]{helvet}
\renewcommand*\familydefault{\sfdefault}
% \usepackage{palatino} % Palatino font
% \usepackage{lucidabr}

% Pour les liens/urls
\usepackage[colorlinks=true,linkcolor=black,citecolor=black,urlcolor=black,filecolor=black]{hyperref}

% Le reste
\usepackage{verbatim}
\usepackage{graphicx}

% Pour ne pas avoir à mettre images/ devant les noms d'images...
\graphicspath{{images/}}
\usepackage{fullpage}
\usepackage{array}
\usepackage[absolute]{textpos}
\usepackage{framed}

% Pour les entêtes et les pieds de page
\usepackage{fancyhdr}
\pagestyle{fancy}
\usepackage{fancybox}

\usepackage{lastpage}
\usepackage{datetime}
\usepackage{multicol}
\usepackage{multirow}
\usepackage{eso-pic}
\usepackage{color}
\usepackage{sectsty}

% Pour avoir de beau listings
\usepackage{listings}
\usepackage{color}
\usepackage{textcomp}
\definecolor{listinggray}{gray}{0.9}
\definecolor{lbcolor}{rgb}{1,1,1}
\lstset{
	backgroundcolor=\color{lbcolor},
	tabsize=4,
	rulecolor=,
% 	language=bash,
	upquote=true,
	aboveskip={1.5\baselineskip},
	columns=fixed,
	showstringspaces=false,
	extendedchars=true,
	breaklines=true,
	prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
	frame=single,
	showtabs=false,
	showspaces=false,
	showstringspaces=false,
	identifierstyle=\ttfamily,
	keywordstyle=\color[rgb]{0,0,1},
	commentstyle=\color[rgb]{0.133,0.545,0.133},
	stringstyle=\color[rgb]{0.627,0.126,0.941},
}

\addtolength{\voffset}{-20pt}
\addtolength{\topmargin}{-6pt}
\addtolength{\headsep}{+12pt}
\addtolength{\footskip}{-4pt}
\addtolength{\textheight}{-23pt}
% \usepackage[top=1.5cm, bottom=5.5cm, left=2.5cm, right=2.5cm]{geometry}

% Pour le glossaire
% \usepackage[xindy, toc]{glossaries}
\usepackage[french]{nomencl}


%%Redefinition de commandes et autres utilitaires

%Ecart entre les colonnes
% \setlength{\columnseprule}{0.5pt}

% Définition des couleurs de l'ENSIB
\definecolor{darkBlueENSIB}{RGB}{0,52,120}
\definecolor{lightBlueENSIB}{RGB}{0,152,195}

\definecolor{fushiaENSIB}{RGB}{203,0,68}
\definecolor{orangeENSIB}{RGB}{255,109,34}

%Changement des couleurs des titres
\partfont{\color{darkBlueENSIB}{}}
\chapterfont{\color{darkBlueENSIB}{}}
\sectionfont{\color{darkBlueENSIB}{}\huge}
\subsectionfont{\color{darkBlueENSIB}{}\Large}
\subsubsectionfont{\color{darkBlueENSIB}{}\large}

\makeindex
% \makeglossaries
\makenomenclature

%Derniere page avec queue du poisson
\newcommand{\lastPage}{
	\newpage
	\strut
	\fancyhf{}
	\renewcommand{\headrulewidth}{0pt}
	\addtocounter{page}{-1}
% 	\AddToShipoutPicture*{\BackgroundPic{atos-logo-light.png}}
	\AddToShipoutPicture*{\BackgroundPic{Tux_n&b_half_1.png}}
	\newpage
}

% Modification du nom de la table des matières
% Ne semble pas fonctionner
% \renewcommand{\contentsname}{Sommaire}
% Titre pour le Glossaire/Index des noms
\renewcommand{\nomname}{Glossary}
%Separateur des dates
\renewcommand{\dateseparator}{-}

\renewcommand{\title}[1]{
	\vspace*{2cm}
	\begin{center}
		\Huge\textbf{{#1}}
	\end{center}
	\vspace{1cm}
}

\renewcommand{\author}[2]{
	\begin{center}
		\textbf{\Large{#1}}\\
		\normalsize{#2}
	\end{center}
	\vspace{0.3cm}
}

\newcommand{\school}[1]{
	\begin{center}
		\large{#1}
	\end{center}
	\vspace{1.0cm}
}


\newcommand{\supervisor}[4]{
	\begin{center}
		\begin{normalsize}
			{\bf#1}\\
			#2\\
			#3\\
			#4
		\end{normalsize}
	\end{center}
}

\newcommand{\clearemptydoublepage}{
	\newpage{
		\pagestyle{empty}
		\cleardoublepage
	}
}

\newcommand\BackgroundPic[1]{
	\put(0,-100){
		\parbox[b][\paperheight]{\paperwidth}{
			\vfill
			\centering
			\includegraphics[width=\paperwidth, height=\paperheight, keepaspectratio=true]{#1}
			\vfill
		}
	}
}

%%
%% Redefinition des en-tetes et pieds de pages
%%
\fancyhf{}
\fancypagestyle{plain}

%%En tete
\lhead{\hspace{2.3cm}\large \textbf{Integrating PIGA-MAC into the Linux kernel\\}}

% \chead{\large \textbf{Integrating PIGA-MAC into the Linux kernel\\}}

\rhead{\includegraphics[height=2.1cm, keepaspectratio=true]{Logo_ENSIB.png}}

%%Pied de page
\lfoot{}

\cfoot{\vspace{-0.8cm}\rule[0pt]{\textwidth}{0.1mm}\small \ovalbox{\thepage/\pageref{LastPage}}}

\rfoot{\ddmmyyyydate \today}

%%
%% DOCUMENT
%%

\begin{document}

\begin{titlepage}
%%
%% Page de couverture
%%

\AddToShipoutPicture*{\BackgroundPic{Tux_n&b_half.png}}

\begin{center}
	\includegraphics[width=5cm, keepaspectratio=true]{Logo_ENSIB.png}
\end{center}

\vspace{0.5cm}

\begin{center}
	\fontsize{30}{30}\selectfont Integrating PIGA-MAC into the Linux kernel\\
	\vspace{2cm}
	\huge 3rd year STI research project\\[20pt] % Projet recherche de 3$^{e}$ année STI
% 	\Large Filière Sécurité et Technologies Informatique\\
\end{center}

\vspace{4.5cm}

\begin{center}
	\begin{tabular}{rl}
		\hspace{7cm}
		\Large Teacher : & \Large Jérémy Briffaut\\[4pt]
		\Large Student : & \Large Timothée Ravier
	\end{tabular}
\end{center}

\end{titlepage}

\newpage

~\thispagestyle{fancy}

\newpage

~

\vspace{1cm}
\addtocounter{page}{-1}

\section*{Acknowledgments}

~

I would like to particularly thank Jérémy Briffaut for his advice. This project is mostly based on his thesis and last years work.

~

I would like to thank Martin Peres for introducing me to the PIGA concept and kernel development.

~

\newpage

\tableofcontents

\newpage

\listoffigures

\newpage

\section*{Introduction} \addcontentsline{toc}{section}{Introduction}

This project is an integral part of my formation at the ENSI de Bourges, a computer science and security french engineering school.

PIGA (Policy Interaction Graph Analysis) is an advanced Mandatory Access Control mechanism designed to enforce security policy on a system. Just like SELinux, PIGA does not directly prevent vulnerability exploitation, but prevents any further action an attacker might attempt to perform on the system.

The current PIGA design faced unexpected problems related to the fact that the decision making part was located in userspace. That's the main difficulty that we're trying to address with this kernel port. Among the other problems that I will have to solve are multi-core and multi-processor related issues. I'll also try to improve performance and ease of use if I succeed in porting the complet PIGA feature set.

I will begin with a short description of all currently available protections for the main open source operating systems such as Linux distributions and some from the BSD family. Then I will proceed to some PIGA reminders, kernel/userspace implementation design. Finally I will compare PIGA-Linux performance to kernel with either nothing, PaX, SELinux, ``classic'' PIGA enabled.

% FIXME

\newpage

\section{State of the art}

\subsection{Context and study limits}

Ce projet de troisième année s'inscrit dans le contexte de la sécurité d'un système d'exploitation.

Objectifs, rectrictions :
\begin{itemize}
	\item restriction au système même, ne prends pas en comtpe les intéractions extérieures au système ;
	\item indépendant le plus possible du matériel (vise à être multiplatforme) ;
	\item les failles entièrement matérielles ne sont pas prises en compte (carte réseau defectueuse...) ;
% TODO Trouver un endroit où mettre ça
% 	\item contrainte liée à la disponibilité du code source : utilisation du noyau Linux ;
% 	\item contrainte liée aux parts de marché / utilisation actuelle et future / quasi absence de MAC (TrustedBSD ?) : pas de FreeBSD, OpenBSD, NetBSD ;
\end{itemize}

% La majeur partie des systèmes d'exploitation actuels ont intégré une forme de contrôle d'accès pour assurer un minimum de sécurité et de contrôle sur les activités des utilisateurs, dans le but de limiter les effets d'une attaque sur un système. Dans les faits, ce contrôle n'est pas suffisant et ne peut empêcher, par exemple, la compromission d'un système par l'intermédiaire d'un service possédant les droits d'administrateur \cite{TIOF}, ou l'échange d'informations par flux indirects, comme des fichiers temporaires.

% Plus généralement, c'est dans l'absence de mécanisme de sécurité global imposé à un système que réside les manques des modèles de sécurité classique. Plus que simplement le noyau et les applications, ce sont l'ensemble des intéractions entre tous ces éléments qui doivent être contrôlées. Nous allons détailler les différents objectifs à atteindre avant de poursuivre sur les modèles théoriques et leur implémentation dans les systèmes d'exploitation modernes.

%  Nous allons détailler les objectifs à atteindre avant de présenter les différentes solutions disponibles.
% Il existe différents mécanismes qui permettent d'apporter des couches de sécurité à un tel système. Nous détaillerons donc les principes fondateurs de la sécurité pour enchaîner sur les solutions disponibles.

Réduction au concept de sujet et objets. (mode de représentation sur les systèmes actuels)
% FIXME Nous allons réduire les concepts d'utilisateurs et d'applications aux ``simples'' processus qui sont la base de toute interaction avec un système. De même, les fichiers, sockets, les IPC sont autant d'éléments sur lesquels un processus peut agir et nous les regrouperons sous le terme d'objet.

\subsection{Generality}

\subsubsection{Security objectives}

La sécurité d'un système d'information et plus particulièrement la sécurité des systèmes d'exploitation réside dans l'application de mesures visant à atteindre les objectifs suivants :

\textbf{Confidentialité :}
Les informations ne doivent être accessibles qu'aux utilisateurs qui en ont besoin et qui disposent des privilèges correspondant. Exemple : Il ne doit notamment pas être possible de divulguer des informations confidentielles à un niveau de confiance inférieur.

\textbf{Intégrité :}
Le système doit rester dans un état cohérent. Exemple : Les informations importantes comme les mots de passe, les programmes installés, les fichiers de configuration ne peuvent être modifiés par des utilisateurs non privilégiés.

\textbf{Disponibilité :}
Le système doit être réactif, stable et utilisable. Les programmes doivent pouvoir fonctionner correctement. Les contrôles de sécurité supplémentaires instaurés ne doivent pas limiter les capacités légitimes du système et des applications.

~

Toutes les autres propriétés (non répudiation, authenticité...) peuvent être exprimées comme combinaison des objectifs ci-dessus. Exemples :
\begin{itemize}
	\item abus de privilèges :
	\item ...
\end{itemize}

~

Nous avons choisit de nous concentrer sur les deux premières propriétés que sont la confidentialité et l'intégrité. Les scnarios de type dénis de service (Denial of Service) ne sont donc pas pris en compte par exemple, car ils visent à réduire / supprimer la disponibilité d'un système. Les références futures aux objectifs de sécurité en concernerons donc que ceux deux premiers.

En revanche, une solution de sécurité ne doit pas rendre impacter de façon trop importante ou rendre inutilisable un système. Ainsi nous essaierons de limiter l'impact sur les performances de la solution utilisée.

\subsubsection{Principle of least privilege}

Une des techniques les plus couramment utilisées pour tenter d'atteindre ces objectifs consiste à appliquer le principe de séparation des privilèges ou principe de moindre privilège. Il stipule qu'un programme (contrôlé ou non par l'utilisateur) ne doit disposer que des droits strictement nécessaires à son bon fonctionnement.

Par exemple, un logiciel de traitement de texte n'a pas besoin d'avoir accès aux informations sensibles du système comme la liste des utilisateurs ou la liste des mots de passe.

Tous les principaux systèmes d'exploitation actuels disposent maintenant de mécanismes mettant en place la séparation des privilèges. L'application la plus courante de ce principe est la séparation entre les différents comptes sur un système. Une application lancée par un utilisateur ne bénéficie que des droits accordés à cet utilisateur.

Il faut cependant noter que ce principe ne constitue pas une démarche exhaustive permettant d'assurer des objectifs de sécurité.

\subsubsection{Who do I need to trust?}

Il est possible d'employer différentes approches pour s'assurer de la sécurité d'un système d'exploitation, mais chacune d'entre elles repose à un moment ou un autre sur la confiance que l'on a dans l'un des éléments qui la constitue. On distingue ainsi plusieurs situations \cite{WCS}:

\begin{itemize}
  \item faire confiance à tous les logiciels à propos du respect de la politique de sécurité, tout en étant conscient que les logiciels ne sont pas de confiance ;% Trust all the software to abide by a security policy but the software is not trustworthy (this is computer insecurity).
  \item faire confiance à tous les logiciels à propos du respect de la politique de sécurité et s'assurer que le logiciel est validé et fiable (analyse complète et exhaustive de tous les cas d'utilisations, de toutes les branches du code) ;% Trust all the software to abide by a security policy and the software is validated as trustworthy (by tedious branch and path analysis for example).
  \item ne faire confiance à aucun programme, mais imposer une politique de sécurité même si la fiabilité de cette politique et son moyen d'application ne sont pas complétement assurés ;% enforce a security policy with mechanisms that are not trustworthy (again this is computer insecurity).
  \item ne faire confiance à aucun programme, mais s'assurer qu'une politique de sécurité est appliquée par des mécanismes matériels de confiance.% trustworthy hardware mechanisms.
\end{itemize}

Les modèles de sécurité standard se situent tous dans la première catégorie alors que les méthodes que nous allons présenter par la suite peuvent être placées dans les catégories trois et quatre. Le test complet de tous les logiciels présents sur un système d'exploitation est une tâche difficilement réalisable si l'on considère la diversité des matériels disponibles et la complexité d'une application telle que le noyau d'un système d'exploitation. Il existe des systèmes d'exploitation et plus particulièrement des noyaux certifiés Critères Communs \cite{CCCERT}, tel QNX\cite{QNX}, qui peuvent être classés dans la catégorie 2. En revanche, le code source de ces différents systèmes n'étant pas disponible librement, nous ne les détaillerons pas dans ce document.

% An example of hardware based integrity control

% \begin{figure}[h]
% 	\centering
% 	\includegraphics[scale=0.70]{attachements/techrefresh-info-txtfull.png}
% 	\caption{Intel Trusted Execution Technology}
% \end{figure}

\subsection{Les différentes méthodes de contrôle d'accès}

Pour atteindre les objectifs détaillés précédemment et obtenir la séparation et la minimisation des privilèges, les systèmes d'exploitations actuels ont implenté différentes méthodes de contrôle d'accès. Nous allons donc les présenter dans cette partie.

\subsubsection{Discretionary Access Control (DAC)}

Le contrôle d'accès discrétionnaire correspond à un modèle laissant à l'utilisateur, et donc aux programmes, tout contrôle sur les droits accordés aux objets qu'il possède. Un logiciel dispose ainsi la plupart du temps de droits bien superieurs à ces besoins (Firefox a par exemple accès à la liste des comptes utilisateurs). Un sujet (utilisateur ou logiciel) peut ainsi compromettre la confidentialité d'un système en accordant des droits importants à d'autres utilisateurs sur les fichiers qu'il possède. Ce modèle ne permet pas d'assurer la confidentialité, l'intégrité d'un système. Il est à ranger dans la première catégorie des modèles qui font confiance aux logiciels sans imposer de contrôle de sécurité fort.

\subsubsection{Mandatory Access Control (MAC)}

Le contrôle d'accès mandataire repose sur la séparation entre les applications et l'entité prenant la décision d'autoriser ou d'interdire une action. Cette entité peut être implémentée au sein du noyau ou à l'aide de mécanismes externes au système, matériels \cite{ITXT}. Ce modèle permet d'assurer la conformité du système à un ensemble de règles qui forme une politique de sécurité. Il est ainsi possible d'appliquer le principe de moindres privilèges en partant d'une base n'autorisant aucune interaction puis en rajoutant progressivement des interactions autorisées. Le contrôle d'accès mandataire correspond aux catégories trois et quatre, où l'on ne fait pas confiance aux applications pour se reposer sur la mise en \oe{}uvre d'une politique de sécurité plus ou moins fiable.

\subsubsection{Multilevel Security and Multi Categories Security (MLS \& MCS)}

Le modèle de sécurité multiniveau permet d'atteindre certains des buts fixés comme l'intégrité ou la confidentialité. Il repose sur la séparation des objets/sujets en plusieurs domaines, imposant des règles limitant les interactions entre ces mêmes domaines.

\textbf{Bell-LaPaluda :} Ce modèle préserve la confidentialité de l'information en n'autorisant un sujet à écrire uniquement dans un niveau de confidentialité supérieur ou égal, et à ne lire que dans un niveau de sécurité inférieur ou égal. Ce modèle présente plusieurs inconvénients majeurs parce qu'il ne permet pas d'imposer des contraintes d'intégrité et ne permet pas de faire de distinctions précises entre deux personnes possédant le même niveau d'accréditation.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{bell-lp}
	\caption{Le modèle Bell-LaPadula}
\end{figure}

\textbf{Biba :} A contrario du modèle précédent, c'est l'intégrité qui est préservée, car seules les modifications dans un niveau de sécurité inférieur sont autorisées, et la lecture ne peut se faire que sur un niveau d'intégrité supérieur.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{biba}
	\caption{Le modèle Biba}
\end{figure}

Les modèles suivant ne peuvent donc se suffirent à eux-mêmes car ils ne permettent pas d'atteindre plus d'un ou deux objectifs à la fois. Ils posent aussi le problème de la sur-classification des données (toutes les données devenues confidentielles), conduisant à l'introduction d'une méthode de dé-classification de l'information, compromettant l'ensemble du modèle.
En pratique, ces modèles peuvent être utilisés sur des ensembles restreints comme nous le verrons par la suite.

\subsubsection{Role Based Access Control (RBAC)}

Plus qu'un modèle réel de contrôle, c'est un modèle d'administration permettant de simplifier le travail de l'administrateur d'un système utilisant un contrôle mandataire. Le principe du contrôle d'accès mandataire consiste à attribuer des rôles à chaque utilisateur de la machine. Ces rôles donnent ainsi accès à différents éléments du système. Par exemple, les rôles d'utilisateur, d'administrateur et de webmestre peuvent être définis et un utilisateur classique pourra se voir attribuer le rôle de webmestre lui autorisant de modifier les pages disponibles sur un serveur sans avoir besoin de donner un accès administrateur complet à cette personne.

\subsubsection{Type Enforcement}

Ce principe repose sur l'association d'un contexte de sécurité à chaque sujet et objet (pocessus, socket, fichier...). L'accès à un object par un sujet doit correspondre à une règle de la politique de sécurité pour être autorisé. Ce modèle nécessite l'attribution d'un contexte de sécurité à tous les objets du système, y compris les fichiers présents sur les supports de stockage.

\subsection{Available solutions to enforce Mandatory Access Control}

Nous allons détailler les implémentations de ces modèles de sécurité dans certains systèmes d'exploitation, notamment les systèmes ``libres'', pour lesquels nous pouvons avoir accès au code source : Linux et la famille des BSD.

\subsubsection{Simplified Mandatory Access Control Kernel (SMACK)}

\subsubsection{TOMOYO Linux}

\subsubsection{Application Armor (AppArmor)}

\subsubsection{Security Enhanced Linux (SELinux)}

SELinux est une implémentation d'un mécanisme de contrôle d'accès mandataire basé sur le ``type enforcement'', de niveaux de sécurité/confidentialité non prédéfinis, et d'un contrôle d'accès basé sur les rôles. SELinux a été développé par la National Security Agency (NSA) et a été intégrée au noyau Linux une fois que l'architecture des Linux Security Modules fut mise en place. SELinux permet de contrôler pour chaque appel système la validité de l'interaction par rapport aux définitions d'une politique. On associe à chaque objets et processus un context de sécurité. L'accès à un object par un processus doit correspondre à une règle de la politique SELinux pour être autorisé. Il faut noter que chaque décision est prise indépendamment des précédentes : SELinux n'as pas de mémoire des transitions effectuées sur un système. C'est cette limitation et la possibilité d'utiliser les flux d'informations indirects, donc non contrôlés par SELinux, qui ont poussé la création de PIGA.
\begin{list}{}{}
 \item \textbf{Contrainte pour l'administrateur :} Il faut décrire la totalité des interactions possibles pour chaque programme présent sur un système. Il faut s'assurer du bon fonctionnement de ces politiques. Il n'existe pas d'outils pour valider les politiques SELinux. Seuls certains systèmes de fichiers supportent les attributs étendus nécessaires à la labelisation des fichiers présents sur les supports de stockage.
 \item \textbf{Avantages :} Séparation fine des privilèges et des rôles, intégrée dans le noyau. Des politiques ont déjà été écrites. Il existe une distribution facilitant le déploiement de ce type de protection : Fedora.
\end{list}

\subsubsection{Policy Graph Interaction Analysis - Mandatory Access Control (PIGA-MAC)}

L'ensemble désigné sous le nom de PIGA est le résultat de la thèse de Jérémy Briffaut ainsi que des contributions de l'équipe SDS du LIFO, et des étudiants de l'ENSIB. Il est constitué notamment d'une sur-couche à SELinux permettant de définir et imposer des propriétés de sécurité à l'échelle du système en plus des contrôles au niveau des interactions effectués par SELinux. Il apporte une ``mémoire'' à SELinux. Un tel résultat est obtenu après génération du graphe complet des interactions possibles et autorisées par une politique SELinux, recherche de chemins interdits, et consignation de ces chemins. Cette solution permet un contrôle plus avancé sur les flux d'informations dans un système, qu'ils soient directs ou indirects.
\begin{list}{}{}
 \item \textbf{Contrainte pour l'administrateur :} Connaissance du langage de définition de propriété PIGA, maîtrise préalable de SELinux, pré-requis matériels pour la ``compilation'' des politiques.
 \item \textbf{Avantages :} Un contrôle très fin sur les interactions dans un système, restriction (statique) des privilèges maximale.
\end{list}

Le système d'exploitation PIGA-OS basé sur la recherche effectuée sur PIGA a été vainqueur du concours Sec\&Si organisé par l'Agence Nationale pour la Recherche (ANR) \cite{PIGASAINTMALO}\cite{PIGAPROP}.

\subsubsection{PaX \& grsecurity}

grsecurity est une autre implémentation des mécanismes de contrôle d'accès mandataire et des listes de contrôle d'accès. Il permet aussi une gestion des droits basée sur les rôles. Souvent associé à \textsc{grsecurity}, PaX est un patch pour le noyau Linux ajoutant des restrictions et des contrôles sur les accès à la mémoire.
\begin{list}{}{}
 \item \textbf{Contrainte pour l'administrateur :} Certains programmes ne fonctionnent plus avec les restrictions implémentées par PaX. Il faut organiser correctement les binaires car la labellisation est effectuée par rapport à l'arborescence
 \item \textbf{Avantages :} Protection avancée de l'utilisation de la mémoire avec PaX (pile non exécutable, ...), fonctionnement un peu plus simple que SELinux
\end{list}

\subsubsection{W\^{}X \& TrustedBSD}

Présentation de W\^{}X.

Le projet TrustedBSD consiste à intégrer à FreeBSD des fonctions de sécurité telles que les attributs étendus pour le système de fichier UFS2, les listes de contrôle d'accès, des capacités d'audit liées à la sécurité, plusieurs méthodes de contrôles d'accès mandataire.

% \subsubsection{PIGA-SYSTRANS ou contextd}
%
% Contextd est un démon chargé de coordonner différents mécanismes de sécurité sur un système Linux. En effet, dans toutes les solutions décrites précédemment, les programmes se voyaient attribuer les droits dont ils avaient besoin, pour toujours. Une application utilisant ponctuellement le réseau se voyait attribuée le droit définitif d'utiliser un port. Contextd introduit la notion de domaine (web, impôts, ...) lié à une activité particulière de l'utilisateur. Les programmes surveillés n'ont le droit de faire que ce qui leur est autorisé dans le domaine courant.
% \begin{list}{}{}
%  \item \textbf{Contrainte pour l'administrateur :} Maîtrise de SELinux, PIGA. Rédaction et test des règles exhaustives pour faire fonctionner les programmes avec contextd. Certains programmes nécessitent des modifications, surtout lorsque ceux-ci ont un comportement inter-domaine.
%  \item \textbf{Avantages :} Presque la plus fine implémentation du principe de moindre privilèges.
% \end{list}

% Pax = sécurité automatique
% SELinux, GrSec = MAC qui contrôle les accès directs
% PIGA = contrôle les accès indirects
% iptables contrôle le trafic réseau
%
% contextd = chef d'orchestre + changement dynamique des règles des autres  mécanismes de protection pour adapter les permissions au domaine d'utilisation.
%
% Chercher tous les systèmes de MAC/DAC/RBAC,...
%
% Classer les MAC en fonction du travail à faire par l'administrateur ? en fonction d'où ils agissent ? par rapport à la logique interne (stateless ou statefull) ?

\newpage

\section{Development and test environment}

PIGA features are intrinsically link to SELinux features so the choice of development environment was limited. The main GNU/Linux distributions supporting SELinux are :
\begin{itemize}
	\item Red Hat Enterprise Linux \cite{RHEL}, CentOS \cite{CENTOS}, Scientific Linux \cite{SL}
	\item Fedora \cite{FEDORA}
	\item Gentoo \cite{GENTOO} with the Hardened Gentoo project \cite{GENTOOH}
\end{itemize}
As PIGA-OS is based on Hardened Gentoo, I chose to stick with this distribution.

\subsection{Hardened Gentoo}

The Hardened Gentoo Project has taken upon the goal of building a completly secure operating system from the ground up. To achieve this goal, several particularities have been selected :
\begin{itemize}
	\item a linux kernel with the PaX \& grsecurity patch
	\item a carefully crafted une configuration and several restrictive compilation options
	\item a modular SELinux policy
\end{itemize}

The first step of this project was to setup a virtual Hardened Gentoo development environment.

The Gentoo choice was also driven by the fact that I had to understand most of the building process in order to make it work properly. This constrain was actualy a benefit.

\subsection{QEMU, KVM and the Virtual Machine Manager}

In order to ease the development process, I used some KVM and QEMU special features. QEMU enabled me to use an externaly (as in: not on a virtual drive) compiled kernel. I saved a lot of time compiling kernels on the host system instead of the virtual one. As the host and the virtual machine architecture matchs (x86\_64, no cross-compilation involved) I was able to use this kernel into a Gentoo virtual machine.

% FIXME
% \subsection{Related tests}

% This virtual environment allowed me to test several of the available solutions (SMACK, TOMOYO...).
% J'ai ainsi créé une machine virtuelle pour chaque solution et j'ai testé les scénarios d'attaques et la réponse que pouvait apporter un administrateur à ces scénarios.
% Violation d'intégrité :
% Violation de confidentialité :
% \subsection{Résultats}
% Tableau comparatif avec le DAC...

\newpage

\section{PIGA-Linux}

\subsection{Objectives}

The following objectives (and implementation order) were layed out with Jérémy Briffaut at the begining of the project :

\begin{enumerate}
	\item Implement a basic decision making algorithm in the kernel
	\item Create userspace tools to load a PIGA policy into the kernel
	\item Optimize the policy storage into the kernel to handle large policy (more than three hundred thousand signatures) in order to make this usefull in the real world
	\item Implement remaining PIGA-IDS and PIGA-IPS fonctionnality (conditionnal policy, process based signatures, better audit features, rule learning, state save and restore...)
\end{enumerate}

\subsection{Architecture}

PIGA-Linux is divided between a kernel patch, a userspace tool, and ``standard'' PIGA tools. This project focused only on the kernel patch and the policy loader tool. The ``standard'' tools functionnality will be briefly explained here for convenience.

\subsubsection{PIGA tools}

%FIXME
Tools to generate graphs and policy files from SELinux policy files. IDS and IPS Java stuff. Original kernel patch description.

\subsubsection{Linux kernel implementation}

As of today, the kernel implementation is severly limited in terms of performance, but fullfils the basic purpose of PIGA.

It is also as least intrusive as possible as only two major files need minor modifications. The decision taking algorithm for SELinux regroups every checks in a single function, allowing us to easily add the PIGA control after the SELinux one.
As all SELinux behaviours remain unchanged, PIGA denials currently appear as SELinux denials. For now, we can keep the SELinux auditing interface to audit PIGA denials. In future development, we should include a flag or a special field specifying that this particular denial is related to PIGA.

% Séparer les lectures des écritures d'états des signatures pour faire avancer les signutures.

\subsubsection{Piga Policy Parser}

The PIGA Policy Parser (PPP) is a userspace tool built with Flex and Bison (the GNU Lex \& Yacc equivalent). It parses and checks the correctness of a set of signatures contained in a policy file. Those signatures were previously generated with PIGA related tools from a set of PIGA rules and a SELinux policy.

The PPP currently offers very basic features and options :
\begin{itemize}
	\item -h: prints the help
	\item -v: turns verbose mode on, printing warnings for secrity contexts found in the PIGA policy but not in the loaded SELinux policy
	\item -s: display some statistics from the PIGA policy, such as the count of each security context
	\item NOT IMPLEMENTED YET -c: enable conditionnal signatures (PIGA feature not yet available)
	\item NOT IMPLEMENTED YET -w: enable warning mode (PIGA feature not yet available)
\end{itemize}

\smallskip

In order to load a policy into the kernel, you need to give a policy file to the tool standard input (classic input from a file as an argument will be implemented: ppp [-shvcw] PIGA\_policy.pol) :
\begin{lstlisting}
$ ppp -s < piga_policy.pol
[+] PPP: Beggining PIGA policy parsing and loading...
[+] PPP: Policy successfully parsed. Setting up in the kernel...
[+] PPP: PIGA policy loadded :
[+]     4 signatures have been loaded
[+]     0 signatures have been ignored
[+] Policy stats : '<name> (<uint>): <count>'
[+]     SID stats :
[+]             root:object_r:user_tmp_t (114): 2
[+]             root:sysadm_r:sysadm_t (167): 3
[+]             sysadm_u:sysadm_r:dhcpc_t (219): 2
[+]             sysadm_u:sysadm_r:groupadd_t (215): 2
[+]             sysadm_u:sysadm_r:nscd_t (216): 3
[+]             sysadm_u:sysadm_r:sysadm_t (214): 4
[+]             sysadm_u:sysadm_r:useradd_t (218): 2
[+]             system_u:object_r:locale_t (86): 1
[+]             system_u:system_r:init_t (47): 3
[+]             system_u:system_r:initrc_t (56): 2
[+]             system_u:system_r:sulogin_t (217): 2
[+]     tclass stats :
[+]             file (6): 3
[+]             process (2): 10
[+]     requested stats :
[+]             read: 2
[+]             transition: 10
[+]             write: 1
\end{lstlisting}

In this example, we used the statistics flag to dispaly some informations about the policy loaded. First, PPP tells us that 4 out of 4 signatures have been loaded as none has been ignored. The uint (unsigned int) field correspond to the current number associated with the security context in the kernel. Those numbers change at each reboot, so this display has no further purpose. The sid/uint are retreived throught the kernel interface described in the next section.

\subsubsection{Interface between the kernel and userspace}

For now, the PPP tool is using a custom system call which enables it to quickly load the policy.

\begin{lstlisting}
/** Userspace code **/

#ifdef __x86_64
#define __NR_sys_piga_add_sequence 307
#endif /* __x86_64 */

struct sequence {
	unsigned int length;
	unsigned int current_position;
	unsigned int link_offset;
	char * seq_string;
};

struct link {
	unsigned int cs;
	unsigned int cc;
	unsigned short tclass;
	unsigned int requested;
};

/**
 *  s_len: the number of 'struct sequence' in the 's' vector
 *  l_len: the number of 'struct link' in the 'l' vector
 *  s: the 'struct sequence' vector
 *  l: the 'struct link' vector
**/
syscall(__NR_sys_piga_add_sequence, s_len, l_len, s, l);
\end{lstlisting}

As I'm going to improve the kernel storage of policy, I'll probably change this interface to make it more compliant with current kernel design policy (we should not create any new system call, but use ioctl, or other interfaces like sockets...).

PIGA control from userspace is also a work in progress. Currently, you have to use the /proc/piga folder and send commands to the kernel using availables files. This should also be removed in favor of a more generic and ``approuved'' design such as the /sys/kernel interface.

\begin{lstlisting}
$ ls /proc/piga
getsid  mode  status
$ cat /proc/piga/status /proc/piga/mode
Disabled
Disabled: Full check
$ echo 1 > /proc/piga/status
$ cat /proc/piga/status
Enabled
\end{lstlisting}

The getsid entry allows the PPP to quickly retrieve the unsigned int corresponding to a SID. This should also be moved to a more secure and accepted design (at least a syscall) :

\begin{lstlisting}
$ cat /proc/piga/getsid
0
$ echo "root:sysadm_r:sysadm_t" > /proc/piga/getsid
$ cat /proc/piga/getsid
166
$ cat /proc/piga/getsid
0
\end{lstlisting}

\newpage

\section{Results and thoughts}

\subsection{Performance}

Even in this crude form,PIGA-Linus isn't performing so bad. It takes notably longer to complete syscalls (4 seconds for a simple ``ls'') but the system is still working.

% FIXME Proper tests

\subsection{Design and implementation security}

\subsection{Missing and expected features}

\begin{itemize}
	\item conditionnal policy
	\item process based signatures
	\item better audit features
	\item rule learning (grsecurity feature)
	\item current signature state save and restore
\end{itemize}

\newpage

\section*{Conclusion} \addcontentsline{toc}{section}{Conclusion}

Thanks to this project and the helpful supervision of Jérémy Briffaut, I was able to learn a lot about the SELinux implementation in the Linux kernel, the current PIGA implementation and all of it's features.

% FIXME

% Le principal objectif de ce stage, qui consistait à mettre à jour l'éditeur pour la sortie de QSOS 2.0, est atteint. Les améliorations apportées à O3S simplifieront la tâche de mise à jour de l'application web. De plus, en attendant, la version 1.1 apporte un confort et des corrections de bugs non négligeables par rapport aux versions précédentes.
%
% ~
%
% J'ai ainsi consolidé mes connaissances en JavaScript, XUL, PHP et j'ai découvert les outils autour du format XML (XPath, XSLT, DTD, XSD), et la procédure pour réaliser une extension Firefox de bout en bout.
%
% ~
%
% La participation aux discussions visant à élaborer le format des fiches QSOS 2.0 et de l'Open Source Cartouche ont été particulièrement intéressantes. Mes deux encadrants ont en effet une réelle expérience autour des veilles sur les logiciels et j'ai beacoup appris sur ce sujet.
%
% ~
%
% La très bonne ambiance et l'entraide au sein des membres de l'Open Source Center sont aussi deux facteurs qui ont contribués à la réussite de ce stage.

\newpage

% FIXME
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{40}

% Thèses
\bibitem{THESEBRIFFAUT} Jérémy Briffaut thesis, \url{http://tel.archives-ouvertes.fr/tel-00261613_v1/}

% Articles
\bibitem{LSMINTRO} Chris Wright, Crispin Cowan, Stephen Smalley, James Morris, Greg Kroah-Hartman, \textit{Linux Security Modules : General Security Support for the Linux Kernel}, \url{http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.84.6867&rep=rep1&type=pdf}
\bibitem{NSATIOF} Peter A. Loscocco, Stephen D. Smalley, Patrick A. Muckelbauer, Ruth C. Taylor, S. Jeff Turner, and John F. Farrell. The Inevitability of Failure : The Flawed Assumption of Security in Modern Computing Environments. In Proceedings of the 21st National Information Systems Security Conference, pages 303–314, Arlington, Virginia, USA, October 1998
\bibitem{PIGASAINTMALO} Jérémy Briffaut, Martin Peres, Jonathan Rouzaud-Cornabas, Jigar Solanki, Christian Toinard, Benjamin Venelle, \textit{PIGA-OS : Retour sur le système d'exploitation vainqueur du défi sécurité}, \url{http://renpar.irisa.fr/cfse8/cfse8_16.pdf}
\bibitem{PIGAPROP} Jérémy Briffaut, Jean-François Lalande, Christian Toinard, \textit{Formalization os security properties : enforcement for mac operating systems and verification of dynamic mac policies}, International journal on advances in security, 2:325-343, 2009

% Livres
\bibitem{LKDTE} Robert Love, \textit{Linux Kernel Development, Third Edition}, Pearson Education, Inc.
\bibitem{SELINUXEXAMPLE} Frank Mayer, Karl MacMillan, David Caplan, \textit{SELinux by Example: Using Security Enhanced Linux}, Prentice Hall, Première édition, 6 août 2006

% Présentations
\bibitem{MRHEL5} Daniel J Walsh, Karl MacMillan, \textit{Managing Red Hat Enterprise Linux 5}, \url{http://people.redhat.com/dwalsh/SELinux/Presentations/ManageRHEL5.pdf}

% Sites web
\bibitem{GRSEC} grsecurity website, \url{http://grsecurity.net}
\bibitem{WCS} Wikipedia : Computer Security, \url{http://en.wikipedia.org/wiki/Computer_security}
\bibitem{QNX} QNX Realtime Operating System, \url{http://www.qnx.com}
\bibitem{CCCERT} Certification Critères Commums, \url{http://www.commoncriteriaportal.org}
\bibitem{ITXT} Intel Trusted Execution Technology (TXT), \url{http://www.intel.com/technology/malwarereduction/index.htm}

% Sites distributions GNU/Linux
\bibitem{RHEL} Red Hat Enterprise Linux, \url{http://www.redhat.com/rhel}
\bibitem{FEDORA} Fedora, \url{http://fedoraproject.org}
\bibitem{CENTOS} CentOS, \url{http://www.centos.org}
\bibitem{SL} Scientific Linux, \url{http://www.scientificlinux.org}
\bibitem{GENTOO} Gentoo, \url{http://www.gentoo.org}
\bibitem{GENTOOH} Gentoo Hardened Project, \url{http://www.gentoo.org/proj/en/hardened}

\end{thebibliography}

\newpage

\addcontentsline{toc}{section}{Glossary}

\nomenclature{SMACK}{Simplified Mandatory Access Control Kernel}
\nomenclature{TOMOYO Linux}{}
\nomenclature{SELinux}{Security Enhanced Linux}
\nomenclature{AppArmor}{Application Armor}

\printnomenclature[3cm]

\newpage

\section*{Appendix} \addcontentsline{toc}{section}{Appendix}

\subsubsection*{Notice about the Tux logo displayed on the first and last page}
Originally drewn by Larry Ewing (\href{http://www.isc.tamu.edu/~lewing/}{http://www.isc.tamu.edu/~lewing/}) (with the GIMP) the Linux Logo has been vectorized by me (Simon Budig, \href{http://www.home.unix-ag.org/simon/}{http://www.home.unix-ag.org/simon/}).

These drawings are copyrighted by Larry Ewing and Simon Budig, redistribution is free but has to include this README/Copyright notice.

\lastPage

\end{document}
